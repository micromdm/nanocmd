// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.21.0
// source: query_event.sql

package sqlc

import (
	"context"
	"database/sql"
	"strings"
)

const getEventsByNames = `-- name: GetEventsByNames :many
SELECT
  event_name,
  context,
  workflow_name,
  event_type
FROM
  wf_events
WHERE
  event_name IN (/*SLICE:names*/?)
`

type GetEventsByNamesRow struct {
	EventName    string
	Context      sql.NullString
	WorkflowName string
	EventType    string
}

func (q *Queries) GetEventsByNames(ctx context.Context, names []string) ([]GetEventsByNamesRow, error) {
	query := getEventsByNames
	var queryParams []interface{}
	if len(names) > 0 {
		for _, v := range names {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:names*/?", strings.Repeat(",?", len(names))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:names*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventsByNamesRow
	for rows.Next() {
		var i GetEventsByNamesRow
		if err := rows.Scan(
			&i.EventName,
			&i.Context,
			&i.WorkflowName,
			&i.EventType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByType = `-- name: GetEventsByType :many
SELECT
  context,
  workflow_name,
  event_type
FROM
  wf_events
WHERE
  event_type = ?
`

type GetEventsByTypeRow struct {
	Context      sql.NullString
	WorkflowName string
	EventType    string
}

func (q *Queries) GetEventsByType(ctx context.Context, eventType string) ([]GetEventsByTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, getEventsByType, eventType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventsByTypeRow
	for rows.Next() {
		var i GetEventsByTypeRow
		if err := rows.Scan(&i.Context, &i.WorkflowName, &i.EventType); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOutstandingIDs = `-- name: GetOutstandingIDs :many
SELECT DISTINCT
  c.enrollment_id
FROM
  id_commands c
  JOIN steps s
    ON s.id = c.step_id
WHERE
  c.enrollment_id IN (/*SLICE:ids*/?) AND
  c.completed = 0 AND
  s.workflow_name = ?
`

type GetOutstandingIDsParams struct {
	Ids          []string
	WorkflowName string
}

func (q *Queries) GetOutstandingIDs(ctx context.Context, arg GetOutstandingIDsParams) ([]string, error) {
	query := getOutstandingIDs
	var queryParams []interface{}
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.WorkflowName)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var enrollment_id string
		if err := rows.Scan(&enrollment_id); err != nil {
			return nil, err
		}
		items = append(items, enrollment_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeEvent = `-- name: RemoveEvent :exec
DELETE FROM wf_events WHERE event_name = ?
`

func (q *Queries) RemoveEvent(ctx context.Context, eventName string) error {
	_, err := q.db.ExecContext(ctx, removeEvent, eventName)
	return err
}
